sd_,
r_),
generate_data))
experiment_parameters_grid <- expand_grid(
n_ = seq(seq(25, 400, 25)),
mean_ = c(0,0),
sd_ = c(1,1),
r_ = c(0, 0.3),
iteration = 1:10000)
simulation <-
# using the experiment parameters
experiment_parameters_grid |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_data = pmap(list(n_,
mean_,
sd_,
r_),
generate_data))
simulation <-
# using the experiment parameters
experiment_parameters_grid |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_cor_data = pmap(list(n_,
mean_,
sd_,
r_),
generate_cor_data))
# run simulation ----
simulation <-
# using the experiment parameters
experiment_parameters_grid |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_cor_data = pmap(list(n_,
r_),
generate_cor_data)) |>
# apply the analysis function to the generated data using the parameters relevant to analysis
mutate(analysis_results = pmap(list(generated_data),
analyse_data))
simulation <-
# using the experiment parameters
experiment_parameters_grid |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_cor_data = pmap(list(n_,
r_),
generate_cor_data))
simulation <-
# using the experiment parameters
experiment_parameters_grid |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_cor_data = pmap(list(n_),
generate_cor_data))
simulation <-
# using the experiment parameters
experiment_parameters_grid |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_cor_data = pmap(list(n_, mean_),
generate_cor_data))
simulation <-
# using the experiment parameters
experiment_parameters_grid |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_cor_data = pmap(list(n_, mean_, sd_),
generate_cor_data))
# run simulation ----
simulation <-
# using the experiment parameters
experiment_parameters_grid |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_cor_data = pmap(list(n_, mean_, sd_, r_),
generate_cor_data)) #|>
generate_data <- function(n_control,
n_intervention,
location_control, # location, akin to mean
location_intervention,
scale_control, # scale, akin to SD
scale_intervention,
skew_control, # slant/skew. When 0, produces normal/gaussian data
skew_intervention) {
data_control <-
tibble(condition = "control",
score = rsn(n = n_control,
xi = location_control, # location, akin to mean
omega = scale_control, # scale, akin to SD
alpha = skew_control)) # slant/skew. When 0, produces normal/gaussian data
data_intervention <-
tibble(condition = "intervention",
score = rsn(n = n_intervention,
xi = location_intervention, # location, akin to mean
omega = scale_intervention, # scale, akin to SD
alpha = skew_intervention)) # slant/skew. When 0, produces normal/gaussian data
data <- bind_rows(data_control,
data_intervention)
return(data)
}
experiment_parameters_grid_c <- expand_grid(
# \TODO - see if you can construct this without copy-pasting it from the lesson file
n_control = 100,
n_intervention = 100,
location_control = 0,
location_intervention = 0,
scale_control = 1,
scale_intervention = 1,
skew_control = c(-12, 12),
skew_intervention  =c(-12, 12),
iterations = 1:1000
)
# dependencies
library(tidyr)
library(dplyr)
library(purrr)
library(ggplot2)
library(sn)
install.packages("sn")
library(sn)
experiment_parameters_grid_c <- expand_grid(
# \TODO - see if you can construct this without copy-pasting it from the lesson file
n_control = 100,
n_intervention = 100,
location_control = 0,
location_intervention = 0,
scale_control = 1,
scale_intervention = 1,
skew_control = c(-12, 12),
skew_intervention  =c(-12, 12),
iterations = 1:1000
)
simulation_c <-
# using the experiment parameters
experiment_parameters_grid_c |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_data = pmap(list(n_control,
n_intervention,
location_control,
location_intervention,
scale_control,
scale_intervention,
skew_control,
skew_intervention),
generate_data))
View(simulation_c)
res_t_cohen <- t.test(formula = score ~ condition,
data = simulation_c,
var.equal = TRUE,
alternative = "two.sided")
res_t_cohen <- t.test(
data = simulation_c,
var.equal = TRUE,
alternative = "two.sided")
?t.test
View(simulation_c)
View(simulation_c[[10]][[1]])
View(simulation_c[[10]][[1]])
data_c <- unnest(simulation_c)
View(data_c)
res_t_cohen <- t.test(formula = score ~ condition,
data = data_C,
var.equal = TRUE,
alternative = "two.sided")
res_t_cohen <- t.test(formula = score ~ condition,
data = data_c,
var.equal = TRUE,
alternative = "two.sided")
View(res_t_cohen)
View(simulation_c[[10]][[1]])
# define data generating function ----
generate_data <- function(n_control,
n_intervention,
location_control, # location, akin to mean
location_intervention,
scale_control, # scale, akin to SD
scale_intervention,
skew_control, # slant/skew. When 0, produces normal/gaussian data
skew_intervention) {
data_control <-
tibble(condition = "control",
score = rsn(n = n_control,
xi = location_control, # location, akin to mean
omega = scale_control, # scale, akin to SD
alpha = skew_control)) # slant/skew. When 0, produces normal/gaussian data
data_intervention <-
tibble(condition = "intervention",
score = rsn(n = n_intervention,
xi = location_intervention, # location, akin to mean
omega = scale_intervention, # scale, akin to SD
alpha = skew_intervention)) # slant/skew. When 0, produces normal/gaussian data
data <- bind_rows(data_control,
data_intervention)
return(data)
}
# define data analysis function ----
analyse_data <- function(data) {
res_t_cohen <- t.test(formula = score ~ condition,
data = data,
var.equal = TRUE,
alternative = "two.sided")
# \TODO this function will need to be changed to extract cohen's d instead. While there is code for this in a previous lesson, see if you can rewrite it yourself.
res <- tibble(p = res_t_cohen$p.value,
mean_control = res_t_cohen$estimate[1],
mean_intervention = res_t_cohen$estimate[2])
return(res)
}
# set the seed ----
# for the pseudo random number generator to make results reproducible
set.seed(42)
# define experiment parameters ----
experiment_parameters_grid_c <- expand_grid(
# \TODO - see if you can construct this without copy-pasting it from the lesson file
n_control = 100,
n_intervention = 100,
location_control = 0,
location_intervention = 0,
scale_control = 1,
scale_intervention = 1,
skew_control = c(-12, 12),
skew_intervention  =c(-12, 12),
iterations = 1:1000
)
# run simulation ----
simulation_c <-
# using the experiment parameters
experiment_parameters_grid_c |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_data = pmap(list(n_control,
n_intervention,
location_control,
location_intervention,
scale_control,
scale_intervention,
skew_control,
skew_intervention),
generate_data)) |>
# apply the analysis function to the generated data using the parameters relevant to analysis
mutate(analysis_results = pmap(list(generated_data),
analyse_data))
# summarise simulation results over the iterations ----
simulation_c_summary <- simulation_c |>
unnest(analysis_results) |>
group_by(skew_control, skew_intervention)|>
# # \TODO - the summary across conditions must be group_by()'d the conditions that were manipulated, ie where there is more than one value for the parameter in expand_grid()
# group_by() |>
summarize(false_positive_rate = janitor::round_half_up(mean(p < .05), digits = 3)
# \TODO - this code to summarize the outcomes will need to be adapted
)
# print results table
simulation_c_summary |>
kable() |>
kable_classic(full_width = FALSE)
# summarise simulation results over the iterations ----
simulation_c_summary <- simulation_c |>
unnest(analysis_results) |>
group_by(skew_control)|>
# # \TODO - the summary across conditions must be group_by()'d the conditions that were manipulated, ie where there is more than one value for the parameter in expand_grid()
# group_by() |>
summarize(false_positive_rate = janitor::round_half_up(mean(p < .05), digits = 3)
# \TODO - this code to summarize the outcomes will need to be adapted
)
View(simulation_c_summary)
# summarise simulation results over the iterations ----
simulation_c_summary <- simulation_c |>
unnest(analysis_results) |>
group_by(skew_control,skew_intervention)|>
# # \TODO - the summary across conditions must be group_by()'d the conditions that were manipulated, ie where there is more than one value for the parameter in expand_grid()
# group_by() |>
summarize(false_positive_rate = janitor::round_half_up(mean(p < .05), digits = 3)
# \TODO - this code to summarize the outcomes will need to be adapted
)
View(simulation_c_summary)
# print results table
simulation_c_summary |>
kable() |>
kable_classic(full_width = FALSE)
library(janitor)
# print results table
simulation_c_summary |>
kable() |>
kable_classic(full_width = FALSE)
library(knitr)
# print results table
simulation_c_summary |>
kable() |>
kable_classic(full_width = FALSE)
?kable_classic
library(kableExtra)
# print results table
simulation_c_summary |>
kable() |>
kable_classic
# print results table
simulation_c_summary |>
kable() |>
kable_classic(full_width = FALSE)
# summarise simulation results over the iterations ----
simulation_c_summary <- simulation_c |>
unnest(analysis_results) |>
group_by(skew_control,skew_intervention)|>
# # \TODO - the summary across conditions must be group_by()'d the conditions that were manipulated, ie where there is more than one value for the parameter in expand_grid()
# group_by() |>
summarize(false_positive_rate = round_half_up(mean(p < .05), digits = 3)
# \TODO - this code to summarize the outcomes will need to be adapted
)
# print results table
simulation_c_summary |>
kable() |>
kable_classic(full_width = FALSE)
library(compute.es)
install.packages("compute.es")
test <- cohens.d(simulation_c$score, simulation_c$condition)
test <- cohens.d(simulation_c$score, simulation_c$condition)
library(compute.es)
test <- cohens.d(simulation_c$score, simulation_c$condition)
test <- cohens.d(simulation_c$score, simulation_c$condition)
library(effsize)
?cohen.d
test <- cohen.d(formula = score ~ condition,
data = simulation_c)
View(simulation_c)
View(simulation_c[[11]][[1]])
View(simulation_c[[10]][[1]])
test <- cohen.d(formula = score ~ condition,
data = data_c)
View(test)
# define data generating function ----
generate_data <- function(n_control,
n_intervention,
location_control, # location, akin to mean
location_intervention,
scale_control, # scale, akin to SD
scale_intervention,
skew_control, # slant/skew. When 0, produces normal/gaussian data
skew_intervention) {
data_control <-
tibble(condition = "control",
score = rsn(n = n_control,
xi = location_control, # location, akin to mean
omega = scale_control, # scale, akin to SD
alpha = skew_control)) # slant/skew. When 0, produces normal/gaussian data
data_intervention <-
tibble(condition = "intervention",
score = rsn(n = n_intervention,
xi = location_intervention, # location, akin to mean
omega = scale_intervention, # scale, akin to SD
alpha = skew_intervention)) # slant/skew. When 0, produces normal/gaussian data
data <- bind_rows(data_control,
data_intervention)
return(data)
}
# define data analysis function ----
analyse_data <- function(data) {
res_t_cohen <- cohen.d(formula = score ~ condition,
data = data)
# Ergebnis als Tibble erstellen
res <- tibble(cohens_d = res_t_cohen$estimate)
# \TODO this function will need to be changed to extract cohen's d instead. While there is code for this in a previous lesson, see if you can rewrite it yourself.
return(res)
}
# set the seed ----
# for the pseudo random number generator to make results reproducible
set.seed(42)
# define experiment parameters ----
experiment_parameters_grid_c <- expand_grid(
# \TODO - see if you can construct this without copy-pasting it from the lesson file
n_control = 100,
n_intervention = 100,
location_control = 0,
location_intervention = 0,
scale_control = 1,
scale_intervention = 1,
skew_control = c(-12, 12),
skew_intervention  =c(-12, 12),
iterations = 1:1000
)
# run simulation ----
simulation_c <-
# using the experiment parameters
experiment_parameters_grid_c |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_data = pmap(list(n_control,
n_intervention,
location_control,
location_intervention,
scale_control,
scale_intervention,
skew_control,
skew_intervention),
generate_data)) |>
# apply the analysis function to the generated data using the parameters relevant to analysis
mutate(analysis_results = pmap(list(generated_data),
analyse_data))
# summarise simulation results over the iterations ----
simulation_c_summary <- simulation_c |>
unnest(analysis_results) |>
group_by(skew_control,skew_intervention)|>
# # \TODO - the summary across conditions must be group_by()'d the conditions that were manipulated, ie where there is more than one value for the parameter in expand_grid()
# group_by() |>
summarize(false_positive_rate = round_half_up(mean(p < .05), digits = 3)
# \TODO - this code to summarize the outcomes will need to be adapted
)
View(simulation_c)
View(simulation_c[[11]][[1]])
# summarise simulation results over the iterations ----
simulation_c_summary <- simulation_c |>
unnest(analysis_results) |>
group_by(skew_control,skew_intervention)|>
# # \TODO - the summary across conditions must be group_by()'d the conditions that were manipulated, ie where there is more than one value for the parameter in expand_grid()
# group_by() |>
summarize(false_positive_rate = round_half_up(mean(cohens_d < .05), digits = 3)
# \TODO - this code to summarize the outcomes will need to be adapted
)
# print results table
simulation_c_summary |>
kable() |>
kable_classic(full_width = FALSE)
?t.test
# dependencies
library(tidyr)
library(dplyr)
library(purrr)
library(ggplot2)
library(sn)
library(knitr)
library(janitor)
library(kableExtra)
library(effsize)
library(compute.es)
# simple plot of a normal distribution
set.seed(42)
# define data generating function ----
generate_data <- function(n_control,
n_intervention,
location_control, # location, akin to mean
location_intervention,
scale_control, # scale, akin to SD
scale_intervention,
skew_control, # slant/skew. When 0, produces normal/gaussian data
skew_intervention) {
data_control <-
tibble(condition = "control",
score = rsn(n = n_control,
xi = location_control, # location, akin to mean
omega = scale_control, # scale, akin to SD
alpha = skew_control)) # slant/skew. When 0, produces normal/gaussian data
data_intervention <-
tibble(condition = "intervention",
score = rsn(n = n_intervention,
xi = location_intervention, # location, akin to mean
omega = scale_intervention, # scale, akin to SD
alpha = skew_intervention)) # slant/skew. When 0, produces normal/gaussian data
data <- bind_rows(data_control,
data_intervention)
return(data)
}
# define data analysis function ----
analyse_data <- function(data) {
res_t_cohen <- cohen.d(formula = score ~ condition,
data = data)
res_t_test <- t.test(formula = score ~ condition,
data = data,
var.equal = FALSE,
alternative = "two.sided")
# Ergebnis als Tibble erstellen
res <- tibble(cohens_d = res_t_cohen$estimate,
p = res_t_test$p.value)
# \TODO this function will need to be changed to extract cohen's d instead. While there is code for this in a previous lesson, see if you can rewrite it yourself.
return(res)
}
# set the seed ----
# for the pseudo random number generator to make results reproducible
set.seed(42)
# define experiment parameters ----
experiment_parameters_grid_c <- expand_grid(
# \TODO - see if you can construct this without copy-pasting it from the lesson file
n_control = 100,
n_intervention = 100,
location_control = 0,
location_intervention = 0,
scale_control = 1,
scale_intervention = 1,
skew_control = c(-12, 12),
skew_intervention  =c(-12, 12),
iterations = 1:1000
)
# run simulation ----
simulation_c <-
# using the experiment parameters
experiment_parameters_grid_c |>
# generate data using the data generating function and the parameters relevant to data generation
mutate(generated_data = pmap(list(n_control,
n_intervention,
location_control,
location_intervention,
scale_control,
scale_intervention,
skew_control,
skew_intervention),
generate_data)) |>
# apply the analysis function to the generated data using the parameters relevant to analysis
mutate(analysis_results = pmap(list(generated_data),
analyse_data))
# summarise simulation results over the iterations ----
simulation_c_summary <- simulation_c |>
unnest(analysis_results) |>
group_by(skew_control,skew_intervention)|>
# # \TODO - the summary across conditions must be group_by()'d the conditions that were manipulated, ie where there is more than one value for the parameter in expand_grid()
# group_by() |>
summarize(false_positive_rate = round_half_up(mean(p < .05), digits = 3),
c_d = round_half_up(mean(cohens_d < .05), digits = 3)
# \TODO - this code to summarize the outcomes will need to be adapted
)
# print results table
simulation_c_summary |>
kable() |>
kable_classic(full_width = FALSE)
